# 01. 가장 기본이 되는 자료구조

## 스택과 큐

- 스택 자료구조 

  - 먼저 들어온 데이터가 나중에 나가는 형식

  - 선입후출

  - 입구와 출구가 동일한 형태로 (프링글스 통//먼저 들어온 건 제일 뒤로 갈 수 밖에 없다는 뜻)

  -   파이썬에서 스택 자료구조를 이용하려면

     - 리스트 자료구조를 사용

     - 가장 오른쪽에 원소를 추가하는 .append() 메소드

     - 가장 오른쪽에서 원소를 삭제하는 .pop()메소드

     - ```
       Ex.)
       삽입5-삽입2-삽입3-삽입7-삽입1-삽입4
       => 왼쪽부터 5,2,3,7,1,4 순서로 쌓임
       ```
 
       ```
       stack.append(5)
       stack.append(2)
       stack.append(3)
       stack.append(7)
       stack.pop() # 7이 삭제 됨
       stack.append(1)
       stack.append(4)
       stack.pop() # 4가 삭제됨
       -> [5,2,3,1]
       print(stack[ : : -1 ] ) # 최상단 원소부터 출력
       => [1, 3, 2, 5]
       print(stack) # 최하단 원소부터 출력
       => [5, 2, 3, 1]
       ```

  - C++,  Javs에서 스택 구현을 하는 메소드
    - 추가는 .push()
    - 삭제는 .pop()

- 큐 자료구조

  - 먼저 들어온 데이터가 먼저 나가는 형식

  - 선입선출

  - 입구와 출구가 모두 뚫려있는 터널과 같은 형태

    ```
    Ex.)
    삽입5-삽입2-삽입3-삽입7-삽입1-삽입4
    => 왼쪽부터 4,1,7,3,2,5 순서로 쌓임
    ```

  - 파이썬에서 큐 자료구조를 이용하려면

    - deque 라이브러리를 사용

    - 큐 자료구조를 구할 때에는 파이썬에서 기본적으로 제공하는 리스트를 이용하는 것보다 deque를 이용하는게 훨씬 낫다

      ```
      from collections import deque
      #큐 구현을 위해 deque 라이브러리 사용
      queue = deque
      queue.append(5) # 리스트의 append 와 동일
      queue.append(2)
      queue.append(3)
      queue.append(7)
      queue.popleft() # 가장 왼쪽에 있는 데이터를 꺼냄 => 5가 삭제됨
      queue.append(1)
      queue.append(4)
      queue.popleft() # 2가 삭제됨
      print(queue) # 먼저 들어온 순서대로 출력
      => deque([3, 7, 1, 4])
      queue.reverse() # 역순으로 바꾸기
      print(queue) # reverse로 인해 나중에 들어온 원소부터 출력
      =>deque([4, 1, 7, 3])
      ```

    - C++
      - push, pop
    - Java
      - 추가할 땐 .offer() 메소드
      - 삭제할 땐 .poll() 메소드
        - 단순히 꺼내는 것만이 아니라 바로 반환해줌

# 02. 우선순위에 따라 데이터를 꺼내는 자료구조

- 우선순위 큐

  -  우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조

  - 데이터를 우선순위에 따라 처리하고 싶을 때 사용

    - Ex). 물건데이터를 자료구조에 넣었다가 가치가 높은 물건부터 꺼내서 확인해야 하는 경우

  - ```
    스택 : 가장 나중에 삽입된 데이터가 추출됨
    큐 : 가장 먼저 삽입된 데이터가 추출됨
    우선순위 큐 : 가장 우선순위가 높은 데이터가 추출됨
    ```

  -  구현하는 방법

    1. 리스트 이용
       - 데이터를 차례대로 쭉 연결한 뒤 리스트에서 각각의 데이터를 확인 한 뒤에 값이 가장 큰 데이터를 추출
    2.  힙을 이용
       - N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일(힙 정렬)
       - 빠른 정렬화 알고리즘?

  -  힙의 특징

    - 완전 이진트리

      - 루트 노드부터 시작하여 왼쪽 자식 노드, 오른쪽 자식노드 순서대로 데이터가 차례대로 삽입되는 트리를 의미

      - 맨 위에서부터 가지치듯 왼쪽, 오른쪽 순서대로 쭉 내려옴

      - ```
                　　　　　　1
                    　　2             3
          4    5       6       7
         8 9 10 11  12 13   14 15
         이런식으로
        ```

      - 

    - 힙은 일종의 트리구조로, 항상 루트노드를 제거

      -  데이터를 넣을 땐 트리에 데이터를 넣고, 꺼낼 땐 루트노드에서 꺼낸다

    - 최소 힙

      - 루트노드가 가장 작은 값을 가짐
      - 따라서 값이 작은 데이터가 우선적으로 제거됨
      - 만약 오름차순 정렬을 수행한다면 최소힙에 N개의 데이터를 그냥 다 넣은 다음에 꺼내기만 하더라도 오름차순 된 결과가 출력이 될 것이다.

    - 최대 힙

      - 루트노드가 가장 큰 값을 가짐
      - 따라서 값이 가장 큰 데이터가 우선적으로 제거

    - 최소힙 구성 함수

      - : Min-Heapify

      - (힙을 구성하기 위한 함수를 보통 Heapify라고 부른다.)

      - 상향식

        - 부모노드로 거슬러 올라가며, 부모보다 자신의 값이 더 작은 경우에 위치

        - ```
                    　　  　1
                      　　5             3
            4    2      
            # 예를 들어 이런 경우, 2가 5보다 작기 때문에 최소 힙 성질을 만족하지 않음
            
                      1
               2            3
            4    5 
            # 그래서 이렇게 최소 힙 성질을 만족하도록 교체하는 것
          ```

        - 힙에 원소가 추가될 때에는 위의 과정처럼 진행됨

        - 반대로 원소가 제거될 때에는 가장 마지막노드가 루트노드의 위치에 오도록 한다

          - 이 후 다시 히피파이 함수가 최소 힙 성질을 만족하도록 교체함

        - ```
                  　　　   2
                      　　5        3
            4    2          9 
            # 예를 들어 이런 경우, 2를 삭제한다면
            
                      9
               5             3
            4    2           
            # 이렇게 가장 마지막의 9가 루트노드로 이동함
            
            # 이후 다시 히피파이가 교체함
                        3
               5             9
            4    2           
          ```

      - 우선순위 큐 라이브러리를 활용한 힙정렬 구현 예제

        - 파이썬의 경우 기본적으로 힙 자료구조는 Min 힙 자료 구조.

          - ```
            # import heapq를 임포트 해서 사용할 수 있음
            #이건 강의에 나왔길래 일단 옮겨 적음
            import sys
            import heapq
            input = sys.stdin.readline
            
            def heapsort(iterable):
            	h = []
            	result = []
            #모든 원소들을 차례대로 삽입
            	for value in iterable:
            		heapq.heappush(h, value)
            
            # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
            	for i in range(len(h)):
            		result.append(heapq.heappop(h))
            	return result
            
            n=int(input())
            arr=[]
            
            for i in range(n):
            	arr.append(int(input()))
            	
            res = heapsort(arr)
            
            for i in range(n):
            	print(resul[i])
            	
            => 오름차순 정렬된 결과가 출력 되는 걸 확인할 수 있다.
            ```

          - 맥스힙으로 정렬하고자 한다면 데이터를 담을 때와 꺼낼 때 -를 붙이면 된다(-h로 변경? )



## 03. 활용도가 높은 자료구조: 트리 자료구조

- 트리는 가계도와 같은 계층적인 구조를 표현할 떄 사용할 수 있는 자료구조
- 트리 관련 용어
  - 루트노드(root node): 부모가 없는 최상위 노드
  - 단말노드(leaf node): 자식이 없는 노드
  - 크기(size): 트리에 포함된 모든 노드의 개수
  - 깊이(depth):  루트노드로부터의 거리(루트노드의 깊이는 0)
  - 높이(height): 깊이 중 최대값
  - 차수(degree): 각 노드의 (자식방향)간선 개수(현재 자신의 노드에서 연결된 자식노드의 개수)

- 기본적으로 트리의 크기가 N일 때, 전체 간선의 개수는 N-1 이다.

- 이진탐색 트리

  - 이진**탐색**이 동작할 수 있도록 고안된 효율적인 탐색이 가능한 자료구조의 일종
  - 왼쪽 자식노드<부모노드<오른쪽 자식노드
    - 부모 노드보다 왼쪽 자식 노드가 작다
    - 부모 노드보다 오른쪽 자식 노드가 크다

  - 

    ```
    　　　　　30
    　 17            48
    5    23       37    50
    
    ```

    - 위와 같을 때, 이진 탐색 트리가 이미 구성되어 있다고 가정하고 데이터를 조회하는 과정은?

      - 찾고자 하는 원소 : 37

      1. 루트 노드부터 방문하여 탐색을 진행한다.
         1. 현재 노드(30)와 찾는 원소 37을 비교
         2. 찾는 원소가 크므로 오른쪽으로 방문
            - 48로 이동하면서 17쪽(17, 5, 23)은 안 찾아봐도 됨-> 시간 단축
      2. 현재 노드(48)보다 찾는 원소 37이 작으니 왼쪽으로 방문
      3.  원소를 찾았으므로 탐색을 종료

- 트리의 순회

  - 트리 자료구조에 포함된 노드를 특정한 방법으로 한번씩 방문하는 방법을 의미

    - 트리의 정보를 시각적으로 학인할 수 있다

  - 대표적인 트리 순회 방법

    - ```
      　　　　 A
        　 B         C
      D    E     F   G
      ```

    - 

    - 전위 순회 : 먼저 루트를 방문 한 뒤 왼쪽, 오른쪽으로 방문 : A-B-D-E-C-F-G

    - 중위 순회 : 왼쪽 자식을 먼저 방문하고 그 다음 루트를 방문한 뒤에 오른쪽으로 방문 : D-B-E-A-F-C-G

    - 후위 순회 : 왼쪽 자식을 방문한 후에 오른쪽 방문 그 뒤에 루트 방문 : D-E-B-F-G-C-A 

  - 트리의 순회 구현 예제

    - 파이썬

    - ```
      class Node:
      def __init__(self, data, left_node, right_node): # 자신의 데이터를 명시, 왼오 노드 명시
      	self.data=data
      	self.left_node=left_node
      	self.right_node=right_node
      #전위순회
      def pre_order(node):
      	print(node.data, dend=' ')
      	if node.left_node != None:
      		pre_order(tree[node.left_node])
          if node.right_node != None:
          	pre_order(tree[node.right_node])
      # 자기 자신의 데이터를 먼저 처리한 뒤 왼, 오 방문
      
      
      #중위순회
      def in_order(node):
      	if node.left_node!= None:
      		in_order(tree[node.left_node])
          print(node.data, end=' ')
          if node.right_node != None:
          	in_order(tree[node.right_node])
      # 왼쪽 먼저 방문, 자기자신 처리, 오른 방문
      
      
          	
      #후위순회
      def post_order(node):
      	if node.left_node!= None:
      		post_order(tree[node.left_node])
          if node.right_node != None:
          	post_order(tree[node.right_node])
          print(node.data, end=' ')
      # 왼, 오 방문 한 뒤 자기 자신 처리
      
      
      ######################################
      # 순회부분보다 여기를 먼저 설명하던데?
      n=int(input() ) #트리의 크기. 즉 노드의 개수
      tree={} # 트리는 딕셔너리를 이용해서 구현 가능
      
      for i range(n)
      	data, left_node, right_node = input().split()
      	if left_node == "None":
      		left_node = None
          if right_node == 'None':
          	right_node = None
          tree[data] = Node(data, left_node, right_node) # 데이터는 트리에 담을 수 있도록, 각 노드는 자기 자신의 데이터와 자신의 왼오 노드가 어떤건지 담을 수 있게
          
      # 데이터를 다 받은 뒤에 전위순회, 중위순회, 후위순회를 출력
      pre_order(tree['A'] )
      print()
      in_oreder(tree['A'] )
      print()
      post_order(tree['A'] )
      
      ###############
      #입력예시
      7
      A B C
      B D E
      C F G
      D None None
      E None None 
      F None None
      G None None
      # => 출력결과
      A B D E C F G
      D B E A F C G
      D E B F G C A
      ```

## 04. 특수하나 목적의 자료구조 : 바이너리 인덱스 트리

- 데이터 업데이트가 가능한 상황에서의 구간 합 문제

  - [백준 '구간 합 구하기 문제'](https://www.acmicpc.net/problem/2042)

- 어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1, 2, 3, 4, 5라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번쨰부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.

- 데이터 개수 : N(1<= N <= 1,000,000)

- 데이터 변경 횟수: M(1<=M<=10,000)

- 구간 합 계산 횟수: K(1<=K<=10,000)

- 이 문제를 어떻게 해결할 수 있을까 

  - 만약, 구간 합을 구할 때마다 일일이 구한다면 N*K만큼의 연산이 필요

- 이럴 때 사용할 수 있는 것이 `바이너리 인덱스 트리`

  - `바이너리 인덱스 트리`는 2진법 인덱스 구조를 활용해 구간 합 문제를 효과적으로 해경해 줄 수 있는 자료구조를 의미

  - `펜윅 트리`라고도 한다

  - K & -K 를 사용...(?)

  - ![image-20211219195031252](알고리즘 기초.assets/image-20211219195031252.png)

    - 0이 아닌 마지막 수가 K?
    - 맨 끝부터 차레대로 1, 2, 4, 8 ... 2의 배수 인 듯

  - ```
    n = 8
    for i in range(n+1):
    	print(i, "의 마지막 비트:", (i & -i) )
    
    ```

- 바이너리 인덱스 트리: 트리 구조 만들기

  - ![image-20211219194958734](알고리즘 기초.assets/image-20211219194958734.png)
  - 특정값을 변경할 때: 0이 아닌 마지마 비트만큼 더하면서 구간들의 값을 변경(바꾸고자 하는 그 특정위치의 값부터 시작해서)

- 바이너리 인덱스 트리: 업데이트

  - ![image-20211219195441297](알고리즘 기초.assets/image-20211219195441297.png)
  - 바꾸고자 하는 특접 값부터 0이 아닌 마지막 비트만큼 더하면서 구간들의 값을 변경
  - 3은 0이아닌 마지막 비트는 1.  그래서 1칸 이동
  - 4에 대한 값 변경. 4에서 4칸 이동
  - 8에대한 값 변경.  8에서 8칸 이동하여 16칸의 값 변경
  - 3, 4, 8, 16은 모두 이 3번째 위치에 대한 값의 합 정보를 담고 있는 인덱스라 할 수 있다
  - 총 4번 값을 업데이트
  - 
  - 

- 바이너리 인덱스 트리: 누적 합

  - ![image-20211219195531597](알고리즘 기초.assets/image-20211219195531597.png)
  - 1부터 11번쨰 까지 누적합을 구한다하면
  - 11부터 시작. 인덱스 11은 11하나의 값을 담고 있고
  - 1만끔 빼서 왼쪽으로 이동
  -  9부터 10까지의 값의 합을 담고 있는 인덱스 10의 값을 더한 뒤 다시 왼쪽으로 2칸 이동
  - 1부터 8까지의 총합을 담고 있는 인덱스 8의 값을 더하면
  - 결과적으로 1부터 11까지 총 11개의 원소의 합계를 구할 수 있게 되는 것

- 파이썬으로 구현

- ```
  import sys
  input = sys.stdin.readline
  
  #데이터의 개수(n), 변경횟수(m), 구간 합 계산 횟수(k)
  n, m, k = map(int, input().split() )
  
  #전체 데이터의 개수는 최대 1,000,000개
  arr=[0]*(n+1)
  tree=[0]*(n+1)
  
  #i번쨰 수까지의 누적합을 계산하는 함수
  def prefix_sum(i):
  	result = 0
  	while i > 0:
  		result += tree[i]
  		#0이 아닌 마지막 비트만큼 뺴가면서 이동
  		i -= (i & -i)
  	retrn result
  # 0이 아닌 마지막 비트만 큼 뺴가면서 앞쪽으로 이동하며 그 합계값을 더해줄 수 있도록
  	
  	
  #i번쨰 수를 dif만큼 더하는 함수
  def update(i, dif):
  	while i <= n:
  		tree[i] += dif
  		i += ( i & -i)
  # i번쨰 수에 대해서 특정값만 큼 더할 떄
  # 트리에서 0이아닌 마지막 비트만큼 이동하며 얼만큼의 값을 더해줄지
  
  
  
  #start부터 end까지의 구간 합을 계산하는 함수
  def interval_sum(start, end):
  	return prefix_sum(den) - prefix_sum(start-1)
  # 기본적으로 구간 합을 구하고자 할 떄 가장 많이 사용
  #end까지의 누적합에서 start-1번쨰 까지의 누적합을 뺴는 방식
  #stat부터 end까지의 구간합을 구할 수 있다
  	
  	
  	
  for i in range(1, n + 1):
  	x = int(input())
  	arr[i] = x
  	update(i, x)
  
  for i in range(m + k):
  	a, b, c = map(int, input().split())
  	# 업데이트(update)연산인 경우
  	if a == 1:
  		update(b, c - arr[b]) # 바뀐 크기(dif)만큼 적용. 특정번째 값에 대해서(b?) 얼만큼 값이 바뀌었는지. 이를 파라미터로 넘김
  		arr[b] = c
  	#구간 합(interval sum)연산인 경우
  	else:
  		print(interval_sum(b,c))
  		#어디서 부터 어디까지의 구간 합을 구할 것인지 출력
  
  
  
  ```



## 05.  간단하면서도 기본적인 정렬알고리즘 : 선택정렬과 삽입정렬

- 정렬이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것
- 일반적으로 문제상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용됨
- 아래의 데이터를 어떻게 정렬할 수 있을까?

```
7, 5, 9, 0, 3, 1, 6, 2, 4, 8
```

- 선택정렬 알고리즘

  - 처리되지 않은 데이터 중 가장 작은 데이터를 선택해서 맨 앞에 있는 데이터와 바꾸는 것을 반복

    ```
    7, 5, 9, "0", 3, 1, 6, 2, 4 # 가장작은 데이터
    [0], 5, 9, 7, 3, 1, 6, 2, 4 # 0을 가장 앞쪽으로
    [0], 5, 9, 7, 3, "1", 6, 2, 4 # 처리되지 않은 데이터중 가작 작은 데이터
    [0], [1], 9, 7, 3, 5, 6, "2", 4
    이런 식으로 반복
    => [0], [1], [2], [3], [4], [5], [6], [7], [8]
    
    ```

    - 파이썬

    - ```
      array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
      for i in range(len(array)):
      	min_index=i # 가장 작은 원소의 인덱스
      	for j in range(i + 1, len(array)):
      		if array[min_index] > array[j]:
      			min_index = j
      	array[i], array[min_index] = array[min_index], array[i] # 스왑
      print(array)
      => [0, 1, 2, 3, 4, 5, 6, 7, 8]
      ```

      ```
      i값은 0부터 데이터 개수-1 까지 반복
      i는 가장 작은 데이터와 위치가 바뀔 그 인덱스
      i는 매번 앞쪽으로 보내고자 하는. 가장 앞쪽의 원소
      반복할 때마다 가장 작은 인덱스를 고를 수 있도록
      이와 같이 min_index로
      일단 맨 처음에는 가장 앞쪽 원소가 가장 작은 원소가 되게 함
      j는 i+1부터 전체 원소 개수-1 까지 차례대로 증가하며 가장 작은 원소를 찾음
      가장 작은 원소보다 더 작은 원소가 있다면 그 위치 인덱스가 min_index 값에 담길 수 있도록
      안쪽의 반복문이 끝났을 때 가장 작은 원소가 가장 앞에 위치하도록
      가장 앞쪽 원소와 가장 작은 원소의 위치가 바뀌도록 스왑 연산
      
      
      
      ```

      

  - 선택정렬은 N번만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.

  - 전체 연산 횟수는 다음과 같다

    - N + (N-1) + (n-2)+ ... + 2 (마지막 남은 수는 어차피 제일 큰 수가 남으니까)

- 삽입정렬

  - 처리되지 않는 데이터를 하나씩 골라 적절한 위치에 삽입

  - 데티어를 하나씩 확인하면서 이 데이터를 어디에 삽입시켜야 맞을까 계산

  - 선택정렬과 비교했을 때 일반적으로 구현 난이도가 더 높지만 더 빠르고 효율적으로 동작

    ```
    "7", 5, 9, 0, 3, 1, 6, 2, 4 # 일단 하나 선택
    [7], "5", 9, 0, 3, 1, 6, 2, 4, 8 # 그 다음인 5 선택. 5를 7의 왼쪽에 둘 것인가, 오른쪽에 둘 것인가 계산
    [5], [7], "9", 0, 3, 1, 6, 2, 4, 8 # 5를 7 왼쪽에 두고 다음 데이터인 9선택
    [5], [7], [9], 0, 3, 1, 6, 2, 4, 8
    반복
    ```

    - 파이썬

    - ```
      array=[5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
      
      for i in range(1, lena(array)):
      	for j in range(i, 0, -1):
      	if array[j]<array[j-1] # 한칸씩 왼쪽으로 이동
      	array[j], array[j-1] = array[j-1],array[j]
      	else: # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
      		break
      print(array)
      ```

    - ```
      array의 두번째 원소부터(첫번째 원소는 비교할 게 없으니) 비교하며 위치를 바꿔
      j는 특점 범위를 반복할 건데, i부터 시작해서 1까지 -1씩 하며 반복
      j는 현재 삽입하고자 하는 그 원소의 위치.
      바로 왼쪽의 데이터와 비교했을 때 자기가 더 작다면 위치를 바꿔줌 그래서 스왑
      만약 현재 확인하고 있는, 스왑하고자 하는 그 데이터가 왼쪽의 데이터보다 크거나 작다면 그 위치에서 멈춤
      
      ```

  - 선택정렬과 마찬가지로 반복문이 두 번 중첩되어 사용

  - 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작

    - 이미 정렬되어 있는 상태에서 다시 삽입정렬을 수행하면? 이동 안 해도 되니까 겁나 빠름



## 06 더 빠른 정렬 알고리즘: 퀵 정렬과 계수 정렬

- 퀵정렬

  - 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법

  - 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나

  - 병합 정려로가 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘

  - 가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터로 설정

```
"5", 7, 9, 0, 3, 1, 6, 2, 4, 8 첫번째 원소를 피벗(기준)으로
왼쪽부터 5보다 큰 데이터를 고르고, 오른쪽부터는 5보다 작은 데이터를 선택. => "7" , "4" 의 위치를 서로 바꿔준다
5, 4, "9", 0, 3, 1, 6, "2", 7, 8
5, 4, 2, 0, 3, "1", "6", 9, 7, 8 왼쪽부터와 오른쪽부터의 위치가 엇갈렸을 때에는 작은 값과 피벗 값의 위치를 바꿔준다
(1, 4, 2, 0, 3), 5, (6, 8, 7, 8) 이렇게 5가 가운데로 위치하면서, 왼쪽은 피벗보다 작은 수들, 오른쪽은 피벗보다 큰 수들로 나뉘게 되는데, 이렇게 피벗을 기준으로 데이터 묶음을 나누는 작업을 분할 이라고 한다.
왼쪽에있는 데이터에서 마찬가지로 정렬을 수행
"1", "4", 2, "0", 3
오른쪽도 마찬가지.
이 작업을 반복해서 수행

```

- 파이썬으로 수행

```
araay = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
def quick_sort(array, start, end):
	if start>= end: # 원소가 1개인 경우 종료
		return
        pivot = start # 피벗은 첫번째 원소
        left = start + 1 # 피벗의 바로 오른쪽을 left로 
        right = end
        while(left<=right):
        	#피벗보다 큰 데이터를 찾을 때까지 반복
        	while (left<= end and array[left] <= array[pivot]):
        		left += 1
        	#피벗보다 작은 데이터를 찾을 때까지 반복
        	while(right>start and array[right] >= array[pivot]):
        		right -= 1
            if(left>right): #엇갈렸다면 작은 데이터와 피벗을 교체
                	array[right], array[pivot] = array[pivot], array[right]
            else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            	array[left], array[right] = array[right], array[left]
	#분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
	quick_sort(array, start, right-1)
	quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array)-1)
print(array)
        	
```

- 파이썬의 장점을 살린 방식

```
araay = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
def quick_sort(array):
	#리스트가 하나 이하의 원소만을 담고 있다면 종료
	if len(array)<= 1:
		return array
    pivot = array[0] # 피벗은 첫번째 원소
    tail = array[1:] # 피벗을 제외한 리스트
    
    left_side=[x for x in tail if <= pivot] #분할된 왼쪽 부분
    right_side=[x for x in tail if x>pivot] #분할된 오른쪽 부분
    
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행하고, 전체 리스트 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(array))

실행결과
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```



- 계수 정렬

  - 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠르게동작하는 정렬 알고리즘
    - 계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용 가능
  - 계수정렬은 동일한 값을 가지는 데이터가 여러개 등잘 할 때 효과적으로 사용할 수 있다. Ex). 성적 등
  - 계수정렬은 때에 따라서 심각 한 비효율성을 초래할 수 있다.
    - Ex). 데이터가 0과 99,999 단 두개만 있을 경우, 그래도 100,000만번 실행해야 됨..
  - 예시
  - ![image-20211222211241430](알고리즘 기초.assets/image-20211222211241430.png)

  - 7확인하고 인덱스 7에 계수 추가 ... 반복
  - ![image-20211222211503462](알고리즘 기초.assets/image-20211222211503462.png)
  - 결과
  - ![image-20211222211544350](알고리즘 기초.assets/image-20211222211544350.png)
  - 
  - 파이썬
  - ![image-20211222211639101](알고리즘 기초.assets/image-20211222211639101.png)



## 각각의 정렬 알고리즘 비교

- ![image-20211222212055199](알고리즘 기초.assets/image-20211222212055199.png)

- 정렬파트 기초 알고리즘 문제

- ![image-20211222212358322](알고리즘 기초.assets/image-20211222212358322.png)

- ![image-20211222212457385](알고리즘 기초.assets/image-20211222212457385.png)

- ![image-20211222212540753](알고리즘 기초.assets/image-20211222212540753.png)

- 문제 해결 아이디어

- ![image-20211222212602559](알고리즘 기초.assets/image-20211222212602559.png)

- 파이썬

- ![image-20211222212648097](알고리즘 기초.assets/image-20211222212648097.png)

  - ```
    n, k, 배열 a 와 배열 b 에 입력을 받는다
    배열a는 오름차순 정렬 수행
    배열 b는 내림차순 정렬 수행
    정렬을 수행할 때 revers=True 하면 내림차순으로 수행
    첫번째 인덱스부터 차례대로 인덱스를 확인
    두 배열의 원소를 최대 k번 비교
    배열 a의 원소가 배열 b원소보다 작으면 a와 b를 교체해서
    배열 a의 모든 원소의 합이 더 커지도록 만들고
    배열 a의 원소가 배열 b보다 크거나 같을 땐 더이상 배열a의 합을 크게 만들 수 없기 때문에 반복문 탈출
    ```

  
