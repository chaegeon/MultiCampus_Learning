# 08 그래프 탐색의 기본, DFS와 BFS
- DFS ( Depth-First Search)
- DFS는 김피 우선 탐색 이라고도 부르며 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.
- DFS는 스택자료구조(혹은 재귀함수)를 이용하며, 구체적인 동작과정은 다음과 같다.
  1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 한다
  2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 처리한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복한다.

- 동작 예시
  - step1![image-20211222223642550](그래프.assets/image-20211222223642550.png) (무방향)
  - step2![image-20211222223758088](그래프.assets/image-20211222223758088.png) ( 2로 이동하면 이제 스택의 최상단 노드는 2가 된다)
  - step 3![image-20211222223830602](그래프.assets/image-20211222223830602.png)
  - step4 ![image-20211222223904168](그래프.assets/image-20211222223904168.png) (가장 깊은 노드는 6?)
  - step5 이제 최상단 노드는 6인데 인접한, 이동할 노드가 없음. 이러면 원소 6을 스택에서 꺼내주고 7로 돌아간다)
  - step6![image-20211222224221857](그래프.assets/image-20211222224221857.png)
  - ![image-20211222224200824](그래프.assets/image-20211222224200824.png) ( 최대한 깊게 들어가는 형태)

- 파이썬
- ![image-20211222224315127](그래프.assets/image-20211222224315127.png)

- ```
  최상단 노드외 인접한 형태를 리스트로 표현
  방문한 목록을 리스트로 표현
  인덱스 0을 사용하지 않기위해 리스트를 9까지 만듦
  해당 노드에 방문하게 하고, 방문한 내역을 알 수 있게 print 함
  스택의 최상단 노드와 연결된 다른 노드를 하나씩 확인하면서  인접한 노드가 방문하지 않은 상태라면 그 노드에 대해서도 마찬가지로 재귀함수를 이용해 방문을 수행. 깊게
  
  ```



- BFS ( Bradth-Fisrt Search)
-  BFS는 **너비우선 탐색**이라고도 하며, **그래프에서 가까운 노드부터** 우선적으로 탐색하는 알고리즘
- BFS는 큐 자료구조를 이용하며, 구체적인 동작과정은 다음과 같다
  1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 한다
  2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를  **모두**  큐에 삽입항 처리한다.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복한다

- step1)![image-20211222224951147](그래프.assets/image-20211222224951147.png)
- step2)![image-20211222225022014](그래프.assets/image-20211222225022014.png) (큐에 넣을 땐 한번에 넣지만, 순서는 작은 수부터)
- step3)
- ![image-20211222225145500](그래프.assets/image-20211222225145500.png)
- step4)![image-20211222225214342](그래프.assets/image-20211222225214342.png)
- step5)![image-20211222225229393](그래프.assets/image-20211222225229393.png) ( 8은 인접한 노드가 없기 때문에 8은 꺼내기만 하고 무시)
- step6)![image-20211222225333172](그래프.assets/image-20211222225333172.png)



- 파이썬

- ![image-20211222225442489](그래프.assets/image-20211222225442489.png)

- ```
  큐를 위해서 deque 라이브러리를 불러오고
  0번 노드에 대한 내용은 비워두고, 즉 1번부터 8번까지의 노드 -> 9개인덱스의 리스트를 만들고, 0번은 사용하지 않음
  인접한 노드를 리스트로 표현
  방문정보는 visited라는 리스트로 표현
  bf메소드 시작 노드를 큐에 넣어준다
  시작노드를 방문처리한 뒤 큐가 빌 때까지(수행할 수 없을 때까지) 반복
  큐에서 하나의 원소를 꺼내는데,
  정렬에서 배웠던 가장먼저 들어온 원소를 꺼내는 popleft() 사용
  큐에서 원소를 꺼낸 뒤 해당 노드의 번호를 출력해주고, 해당 노드와 인접한 노드를 확인하며 아직방문하지 않은 노드가 있다면 큐에 넣어준다
  
  
  
  ```

- 







# 09 그래프 탐색 실습 : DFS와 BFS 기초 문제풀이

- 문제풀이

  - ![image-20211225212106155](그래프.assets/image-20211225212106155.png) (연결된 부분들을 한덩이로 간주. 즉 연결요소 찾기)
  - ![image-20211225212244632](그래프.assets/image-20211225212244632.png)
  - ![image-20211225212325873](그래프.assets/image-20211225212325873.png) 특정 지점에서 DFS/BFS 기법으로 이동가능한 노드를 방문처리하는 방법으로 풀이
  - ![image-20211225212526246](그래프.assets/image-20211225212526246.png)

- 파이썬

  - ![image-20211225212615203](그래프.assets/image-20211225212615203.png)

  - ```
    먼저 첫째줄에 n과 m을 입력받고
    nn줄에 거쳐서 2차원 리스트
    이때 입력은 공백없이 0과 1로 구성된 문자열형태
    입력받아서 정수형 형태로 바꿔서 리스트로 만들어 준다.
    모든 원소가 0혹은 1인 정수형 리스트가 된다
    모든 노드에 대해 음료수 채우기
    n*m 크기의 각 위치에서 DFS를 수행
    현재 위치에 대해서 이번 에 dfs를 수행, 방문처리가 된 거라면 카운트
    
    주어진 범위를 벗어나면 종료, 그렇지 않으면.
    현재 위치를 방문하지 않았다면 방문처리
    결과적으로 Ture값을 반환
    현재 위치에 대해서 dfs가 수행된 것이기 때문에 result 값을 증가
    연결된 모든 위ㅣㅊ에 대해서 방문철를 진행할 수 있도록
    상하좌우치에 모두 재귀적으로 DFS 호출
    상하좌우의 대해서 호출되는 내용들은 리턴값을 사용하지 않기 때문에
    단순히 연결된 노모든 드에 대해서 방문처리할 목적으로 수행
    결과적으로 dfs는 한번 수행되면 해당 노드와 연결된 모든 노드들도 방문처리할 수 있도록 하고
    시작점 노드 해당노드가 방문처리가 되었다면 , 즉 처음 방문하는 것이라면 그때만 result값을 증가
    
    ```

- 문제

  - ![image-20211225221459255](그래프.assets/image-20211225221459255.png)
  - ![image-20211225221542079](그래프.assets/image-20211225221542079.png) 가장 왼쪽 위 위치에서 가장 오른쪽 아래로 이동할 때의 최소거리
  - ![image-20211225221628786](그래프.assets/image-20211225221628786.png) BFS 사용
    1.  ![image-20211225221822407](그래프.assets/image-20211225221822407.png)인접한 노드 중 값이 1인 노드만 이동가능하다고 판단
    2. ![image-20211225221750360](그래프.assets/image-20211225221750360.png)
    3.  ![image-20211225221950670](그래프.assets/image-20211225221950670.png) 결과적으로 최종단계의 값을 출력

- 파이썬

  - ```
    n,m을 입력받고 2차원 데이터가 담길 수 있는 맵 정보를 입력받고
    공백으로 구분되지 않고 0과 1 로 구성된 문자열이 주어지기 때문에
    문자열로 입력받고 각 원소에 ㄷ해서 인수형으로 변화하고 리스트로 만듦
    그래프를 초기화 한 뒤에
    상하좌우 방향데이터 정의
    BFS 함수 호출
    deque를 호출하고
    
    deque를 이용해서 q 기능 이용
    초기에 x,y로 이루어진 튜플데이터를 담음
    q가 빌 때까지 bfs 수행
    가장 먼저 반복할 때마다 q에서 하나의 원소를 꺼내서 현재 위치에서 네가지 방향으로의 위치를 확인
    그 다음으로 연결된 위치가 공간을 벗어난다면 무시
    또 괴물이 존재해서 이동할 수 없는 위치인 경우 무시
    결과적으로 해당 노드를 방문할 때만 최단거리를 기록할 수 있도록 하고
    바로 직전 노드 위치에서의 최단 거리값에 1을 더한 값을 넣어줄 수 있도록
    다음 위치로 이동할 위치까지는 1만큼 거리가 더 먼 곳이기 때문에
    q에 데이터를 넣으면서 거리값을 증가시킬 수 있다
    결과적으로 가장 오른쪽 아래까지의 최단거리를 반환한다면 정답
    
    ```

  - 

  

  # 





















